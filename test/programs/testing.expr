// This file is a testing scratchpad for generic testing scenarios

func someFunction(int arg1) (var returnValue) {
  for k of [ 2, 4, 5, 9 ] {
    defer Println("value of k: ", k)
    if arg1 < k {
      return { value: k }
    }
  }

  return { something: 0 }
}

Println("return value", someFunction(7))
Println()
Println()
Println("return value", someFunction(9))

struct Engine = {
  float Displacement = 2.4
  string Type = "v6"
  int HP = 235
  string OilType = "5w-20"
  object Warnings
}

var things = {
  thingy := 0
}

// declaring as `var` causes 
// "wtf still got var after switching acting and type"
object normalWarnings = {
  bool lowOil
  bool lowGas
  bool highTemp
  bool lowTirePressure
}

struct Car = {
  //var id
  string Type = "car"
  bool New
  int numOfWheels = 4
  engine := Engine {
    HP: 199
    Warnings: normalWarnings
  }
}

oldWarnings := {
  antique: true
}

// FIXME: this does not work
//something := someFunction(7)
//Println(something)

// FIXME: assinging anything but an object to a var causes it to
// go away...?
oldCar := Car {
  //id: "hey"
  Type: "car"
  New: false
  numOfWheels: 4
  engine: Engine{
    HP: 160
    Warnings: oldWarnings
    // FIXME: this does not work right now
    // Warnings: someFunction(7)
  }
}

Println("Most cars:", Car)
Println("Old cars:" oldCar)

// FIXME: this splatters out a shit ton of text, needs to
// actually print the variable. This will have to be done
// somehow by creating a local variable and then sending
// that into the function
/*
Println("Values for Car struct", Car{
  Type = "truck"
})
*/